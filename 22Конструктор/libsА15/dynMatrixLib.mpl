
read "libs/utilities.mpl"; with(LinearAlgebra); with(ArrayTools); with(plots); with(combinat); with(ListTools); with(Statistics); with(linalg); with(UtilitiesPackage);
DynMatrixLib := module()  option package;        export getDynamicMatrix::static := proc(positions, os1, os2, alfa)  local n,  d;    n:= findN(positions[1]);  d:=add(dynamicStep(pos, os1,os2,n), pos in positions);   return alfa * d;   end proc:    export getDynamicMatrixes::static:=proc(pos, alfa)    result := Matrix(3, 3, (l,j)->getDynamicMatrix(pos, l, j, alfa));  print(result[1,1], alfa);  return result;  end proc:      export getSumOfDynMatrixes::static := proc(groups, alfa)  local sumOfMatrixes;     result := add(getDynamicMatrixes(groups[l], alfa[l]), l=1..numelems(groups));  return result;  end proc:    export makeTemplate::staic:=proc(matrix)  return unapply(matrix, kx,ky,kz);  end proc:     export getGeneralDynamixMatrix::static := proc(setOfPositions, powerConstants, setOfVectors, kx, ky, kz)  local sumOfMatrixesFunc, l, m, n, lenVectors, lenComponents, temp, A, colPosition, rowPosition;      lenVectors := numelems(setOfVectors);  lenComponents:=3;    sumOfMatrixesFunc:=makeTemplate(getSumOfDynMatrixes(setOfPositions, powerConstants)):  rowPosition:=1: colPosition:=1:   A:= Matrix(lenVectors * lenComponents, lenVectors * lenComponents);   for l from 1 to lenVectors do    temp:= sumOfMatrixesFunc(kx+setOfVectors[l][1], ky+setOfVectors[l][2], kz +setOfVectors[l][3]);   for m from 1 to lenComponents do  for n from 1 to lenComponents do  A[rowPosition, colPosition + n - 1] := evalf(temp[m,n]);  end do:  rowPosition := rowPosition + 1;  end do;   colPosition:=colPosition+lenComponents;   end do:  return A;  end proc:    export getDABMatrix::static := proc(setOfPositions, powerConstants, setOfVectors, kx, ky, kz) local lenVectors, lenComponents, numberOfElements,letterMatrix,sumOfMatrixesFunc,l,j,matrixPosition, matrixIndex, A, modifier;    lenVectors := numelems(setOfVectors);  lenComponents:=3;  modifier:=1;    letterMatrix:=DiagonalMatrix([cat(m,1..lenVectors)]);      sumOfMatrixesFunc:=makeTemplate(getSumOfDynMatrixes(setOfPositions, powerConstants, modifier)):   for l from 1 to lenVectors do    cat(m, l):= sumOfMatrixesFunc(kx+setOfVectors[l][1], ky+setOfVectors[l][2], kz +setOfVectors[l][3]);   end do;    return letterMatrix;    end proc:     export getDefMasMatrix::static := proc(listOfVectors, masModFunctions, maxBarrier)   return KroneckerProduct(getRoMatrix(listOfVectors, masModFunctions, maxBarrier), Matrix(3, shape=identity));  end proc;    export getRoMatrix::static := proc(listOfVectors, masModFunctions, maxBarrier)  local l, j,  k, lenqq, B, index, basisVectors,  current, a, possibleVectors;    lenqq := numelems(listOfVectors);  basisVectors :=getBasisVectors(maxBarrier):   B:= Matrix(lenqq, lenqq);    for l from 1 to lenqq do   possibleVectors:=Array(1..lenqq);    for j from 1 to lenqq do  possibleVectors[j]:=listOfVectors[j];  end do;    for j from 1 to lenqq do   current :=listOfVectors[l] - listOfVectors[j];   index:=0;     for k  from 1 to numelems(basisVectors) do   index:= findElemInArray(possibleVectors,current + basisVectors[k]);   if evalb(index> 0) then   B[l,j]:= masModFunctions[index];  possibleVectors[index]:=99999;  break;end if;  end do;     if evalb(index = 0) then B[l, j] := 0 end if;    end do;   end do;   return B;  end proc;      export getFO1::static:=proc(positions, modVectors)  local len:= numelems(modVectors);  return Matrix(len,len, (l,j)->exp((-1)*I*( add(x, x in zip(`*`, positions[l], modVectors[j]))))/len);  end proc;    export getFO::static:=proc(positions, modVectors)  local len :=numelems(modVectors);  return Matrix(len,len, (l,j)->exp( I*( add(x, x in zip(`*`, positions[l], modVectors[j])))));  end proc;          export getMasModFunctions::static := proc (positions, modVectors, masses)  local len, l, j, f1;   len:= numelems(modVectors);  f1:=getFO1(positions, modVectors);    return simplify(evalm(f1&*masses));  end proc:        local sortingGroups::static:=proc(group1,group2)   local n1, n2, result;  n1:= findN(group1[1]);  n2:= findN(group2[1]);  result:= evalb(n1^(2) < n2^(2)):  return  result;    end proc:     local sortingPositions::static:=proc(elem1, elem2)  local n1, n2;  n1:= findN(elem1);  n2:= findN(elem2);  return evalb(evalf(n1^(2)) < evalf(n2^(2)));    end proc:      export getBasisVectors::static:=proc(initialElement)  local basisVariants, buffer, currentSum,l, basisVector, variant, sortproc;  buffer:=table();  buffer[seq([0,0,0])] :=1;     basisVariants:= addValues(initialElement);    for l from 1 to 5 do  for basisVector in indices(buffer) do  for variant in basisVariants do  currentSum:=basisVector+variant;  buffer[seq(currentSum)]:=1;  end do;  end do;   end do;     return sort([indices(buffer)], sortingPositions);   end proc:      export generateGroups::static:=proc(positions)  local uniq, groups, sortproc;  uniq:= MakeUnique([seq(convert(sort(abs(convert(positions[l], Array))), list),l=1..numelems(positions))]);  uniq:=remove(t-> t=[0,0,0], uniq);       groups:= [seq(addValues(uniq[l]), l=1..numelems(uniq))];    sortproc := proc(a, b)  return sortingGroups(a,b);  end  proc;    return sort(groups, sortproc); end proc:    export selectValues::static:=proc(arr, number)  local cleaned, result, i,avg,minDiff,minValue,j;   cleaned:= Array([]):  for i from 1 to numelems(arr)do  if not arr[i]=Inf  and not arr[i] = -Inf  then  Append(cleaned, arr[i]):  end if;  end do;  result:=Array([]);  avg:=0;  for i from 1 to number do  minDiff:=infinity;  minValue:=infinity;  for j from 1 to numelems(cleaned) do  if abs(avg - cleaned[j]) < minDiff then  minValue:=j;  minDiff:=abs(avg - cleaned[j]);  end if; end do:    if minValue < infinity then  Append(result, cleaned[minValue]); cleaned:= removeElem(cleaned, minValue);  end if;      end do;  return sort(result);  end proc;    export addValues::static:=proc(initEl)  local el:=initEl;   return MakeUnique([op(permute(el)), op(permute([-el[1], el[2], el[3]])),op(permute([el[1], -el[2], el[3]])),op(permute([el[1], el[2], -el[3]])),op(permute([-el[1], -el[2], el[3]])),op(permute([-el[1], el[2], -el[3]])),op(permute([el[1], -el[2], -el[3]])),op(permute([-el[1], -el[2], -el[3]]))]);     end proc:      export normalizePowerConstants::static:=proc(powerConstants, groups, positions, masses)  local groupToMassMapping:=Array(1..numelems(powerConstants)),   newConstants:=Array(1..numelems(groups)),   checkGroups:=Array([]),  filledPositions := Array([]),  i, j, betweenPosition;    for i from 1 to numelems(masses) do      for j from 1 to numelems(powerConstants) do             if j > numelems(groups) then              break;          end if;             if findElemInArray(groups[j], positions[i]) > 0 then               groupToMassMapping[j]:=groupToMassMapping[j] + masses[i];                if masses[i] > 0 then                  Append(filledPositions, positions[i]);              end if;          end if;      end do;  end do;    for i from 1 to numelems(powerConstants) do      if groupToMassMapping[i] > 0 then          newConstants[i]:=powerConstants[i];          Append(checkGroups, groups[i]);      end if;  end do;         for startPosition in filledPositions do               for modifierPosition in filledPositions do                  betweenPosition := startPosition - modifierPosition;                    for i from 1 to numelems(groups) do                      if findElemInArray(groups[i], betweenPosition) > 0 then                          newConstants[i]:=powerConstants[i];                      end if;           end do;        end do;     end do;     return newConstants;  end proc:    export createAMatrix::static:=proc(AMatrix, masses)      local result, rowLineLength, currentRow, currentCell, matrixLength, i,j,k, startIndex, endIndex;      currentRow := 1;      currentCell:=1;      matrixLength := numelems(findNonNullValues(masses)) * 3;     result:=Matrix(matrixLength, matrixLength);       for i from 1 to numelems(masses) do         if masses[i] > 0 then             startIndex:=i * 3 - 3;             endIndex:=numelems(masses) * 3 - i * 3 +4;             for j from 1 to 3 do                 for k from 1 to 3 do                     result[currentRow,currentCell - 1 + k]:=AMatrix[startIndex + j,startIndex + k];                    result[currentRow,matrixLength - currentCell + 2 - k]:=AMatrix[startIndex + j,endIndex - k];                 end do;                 currentRow:=currentRow + 1;             end do;             currentCell:=currentCell + 3;         end if;     end do;      return result;  end proc:          export  findN::static:=(pos)->sqrt((pos[1] )^(2)+(pos[2])^(2)+(pos[3])^(2));   export dynamicStep::static:=(pos, os1, os2, n)  ->((pos[os1]*pos[os2] )/n^(2))*(1-exp(I*(kx*pos[1]+ky*pos[2]+kz*pos[3])));      end module: ;

