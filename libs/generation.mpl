
  with(combinat):with(ListTools):with(ArrayTools):interface(rtablesize = 600):   Generation := module()  option object;     export buffer;  export count;    local N;  local startFrom;  local endTo;  local modifier;  local multiplier;  export maxValue;  export invariants;  local maxBarrier;     export ModuleApply::static := proc()          Object( Generation, _passed );  end proc;    export ModuleCopy::static := proc( self::Generation, proto::Generation, N, startFrom, endTo, allowInvariants := false, multiplier:=1)  local variantQueue, currentIndex, checked, mutators, currentBarrier, cache, curValues,possibleStep,n2, general, i;   self:-N:=N;  self:-startFrom:=startFrom;  self:-endTo:=endTo;  self:-buffer:=[[[0,0,0]]]:  self:-count:=1;  self:-multiplier:=multiplier;  detectType(self);    variantQueue:=[self:-modifier]:   currentIndex:=1:  checked:=variantQueue[currentIndex]:  mutators:=addValues(self:-modifier):    currentBarrier:=findN2(checked);     cache:=[];  while  currentBarrier < self:-maxBarrier and inLimit(checked,self:-maxValue) do       curValues:= extractInvariants(self:-invariants, self:-maxValue, addValues(checked), allowInvariants);       self:-buffer:=[op(self:-buffer),  curValues]:       self:-count:=self:-count+nops( curValues);           for i from 1 to nops(mutators) do          possibleStep:=checked + mutators[i];           n2:=findN2(possibleStep):            if n2 > currentBarrier then              general:=sort([abs(possibleStep[1]), abs(possibleStep[2]),abs(possibleStep[3])], (a,b)->a>b);                  if not has(general, cache) then                       cache:= [op(cache),general];                                             stepBarrier:=findN2(possibleStep);                      if not checkInQueue(self, variantQueue, possibleStep, allowInvariants) and stepBarrier < self:-maxBarrier and inLimit(possibleStep,self:-maxValue) then                              variantQueue:=[op(variantQueue),possibleStep];                       end if;                   end if;               end if;           end do:               variantQueue:=sort(variantQueue, sortingGroups);             currentIndex:=currentIndex + 1;           if currentIndex > nops(variantQueue) then              currentBarrier:=infinity;          else                checked:=variantQueue[currentIndex];               currentBarrier:=findN2(checked);          end if;         end do:     end proc;     export detectType::static:=proc(self)  local tModifiers, tBarriers, tInvariants;    tModifiers:= table([GCK=[1,1,0], PKR=[1,0,0], OCK=[1,1,1]]);  tBarriers:=table([GCK= [(self:-N)/(2),(self:-N)/(2),0],PKR=[self:-N,0,0],OCK=[(self:-N)/(2),(self:-N)/(2),(self:-N)/(2)]]);  tInvariants:=table([GCK= [op(addValues([(self:-N)/(2),(self:-N)/(2),0])), op(addValues([self:-N,self:-N,0])),op(addValues( [self:-N,(self:-N)/(2),(self:-N)/(2)])),op(addValues([self:-N,0,0])),op(addValues([self:-N,self:-N,self:-N]))],PKR=[op(addValues([self:-N,0,0])), op(addValues([self:-N,self:-N,0])),op(addValues([self:-N,self:-N,self:-N])),op(addValues([2* self:-N,self:-N,self:-N])),op(addValues([2* self:-N,2* self:-N,self:-N])),op(addValues([2* self:-N,2* self:-N,2* self:-N])),op(addValues([2* self:-N, 0, 0])),op(addValues([2* self:-N,self:-N,0]))],OCK=[op(addValues([(self:-N)/(2),(self:-N)/(2),(self:-N)/(2)])),op(addValues([self:-N,self:-N,self:-N])),op(addValues([self:-N,self:-N,0])),op(addValues([self:-N,0,0]))]]);   self:-modifier:=tModifiers[self:-startFrom];  self:-maxValue:=tBarriers[self:-endTo];  self:-maxBarrier:=findN2(tBarriers[self:-endTo]);  self:-invariants:=tInvariants[self:-endTo];  end proc;      export hasSimilar::static:=proc(invariants, buffer, item)      local i;          for i from 1 to nops(invariants) do               if member(item+invariants[i], buffer)  or member(invariants[i] - item, buffer) then                  return true;              end if;           end do;      return false;  end proc:    export extractInvariants::static:=proc(invariants, maxValue, l, allowInvariants)  local i, results := [];  for i from 1 to nops(l) do  if allowInvariants or not hasSimilar(invariants, results, l[i]) then  results:=[op(results), l[i]];  end if;  end do:    return results;  end proc:      export inLimit::static:=proc(value, maxLimit)  local curValue, curLimit;  curValue:=sort([abs(value[1]), abs(value[2]),abs(value[3])], (a,b)->a>b);  curLimit:=sort([abs(maxLimit[1]), abs(maxLimit[2]),abs(maxLimit[3])], (a,b)->a>b);    return evalb(parse(cat(curValue[1], curValue[2], curValue[3],"<", curLimit[1], curLimit[2], curLimit[3])));  end proc:      export sortingGroups::static:=proc(group1,group2)   local n1, n2, result;  n1:= findN2(group1);  n2:= findN2(group2);    if n1=n2 then  result:=inLimit(group1,group2):  else   result:= n1 < n2:  end if;   return  result;    end proc:     export checkInQueue::static:= proc(self, queue, item, allowInvariants)       local i, invariants:=addValues(item);       for i from 1 to nops(invariants) do           if not allowInvariants and hasSimilar(self:-invariants, queue, invariants[i]) then              return true;           end if;         end do:        return false;  end proc:    export printResults::static:=proc(self)  local i;  for i from 1 to nops(self:-buffer) do  print(self:-buffer[i]):  print(nops(self:-buffer[i]));  print("-----------------------");  end do;  end proc:    export flatten::static:=proc(self)  local result:=[], i;  for i from 1 to nops(self:-buffer) do  result:=[op(result), op(self:-buffer[i] * self:-multiplier)];  end do;  return result;    end proc;    export addValues::static:=proc(initEl)  local el:=sort(initEl,`>`);   return MakeUnique([op(permute(el)), op(permute([-el[1], el[2], el[3]])),op(permute([el[1], -el[2], el[3]])),op(permute([el[1], el[2], -el[3]])),op(permute([-el[1], -el[2], el[3]])),op(permute([-el[1], el[2], -el[3]])),op(permute([el[1], -el[2], -el[3]])),op(permute([-el[1], -el[2], -el[3]]))]);      end proc:       local  findN2::static:=(pos)->(pos[1] )^(2)+(pos[2])^(2)+(pos[3])^(2);         end module:  ;

