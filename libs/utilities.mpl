
with(ListTools); with(combinat); with(LinearAlgebra); UtilitiesPackage := module () export findElemInArray, findNonNullValues, findInterval, getInRange, roundToCertainDigits, flipTable, removeElem, checkCircularity, absArray, addValues, checkHermitCondition, arrayDiff; option package;  findElemInArray := proc (arr, el) local i; for i to numelems(arr) do if arr[i] = el then return i end if end do; return 0 end proc; findNonNullValues := proc (arr) return Array(select(proc (l) options operator, arrow; 0 < l end proc, convert(arr, list))) end proc; findInterval := proc () local l, minVal, maxVal, result; minVal := infinity; maxVal := -infinity; for l to _nrest do if min(`$`(_rest[l])) < minVal then minVal := min(`$`(_rest[l])) end if; if maxVal < max(`$`(_rest[l])) then maxVal := max(`$`(_rest[l])) end if end do; return [minVal, maxVal] end proc; flipTable := proc (t) local keys, values, result, l, len; keys := Array([indices(t, 'nolist')]); values := Array([entries(t, 'nolist')]); result := table(); len := numelems(keys); for l to len do if not member(values[l], [indices(result, 'nolist')]) then result[values[l]] := Array([]) end if; Append(result[values[l]], keys[l]) end do; return result end proc; getInRange := proc (current, rangeList) return piecewise(type(rangeList, 'list'), piecewise(evalb(max(rangeList) = rangeList[2]), max(min(rangeList[2], current), rangeList[1]), max(rangeList[2], rangeList[1]-current)), rangeList) end proc; roundToCertainDigits := proc (x, n::integer := 1) `~`[parse](`~`[sprintf](cat("%.", n, "f"), x)) end proc; removeElem := proc (arr, i) local t, l, result; t := whattype(arr); l := convert(arr, list); l := subsop(i = NULL, l); result := convert(l, t); return result end proc; absArray := proc (arr) local i, loc; loc := arr; for i to numelems(loc) do loc[i] := abs(loc[i]) end do; return loc end proc; checkCircularity := proc (checkedMatrix, printNonEqual := false) local firstRow, countOfRows, i, checkedRow, j, elemIndex; firstRow := Row(checkedMatrix, 1); countOfRows := RowDimension(checkedMatrix); print(countOfRows, firstRow); for i to countOfRows do checkedRow := convert(Row(checkedMatrix, i), list); for j to numelems(firstRow) do if has(checkedRow, firstRow[j]) then elemIndex := Search(firstRow[j], checkedRow); checkedRow := subsop(elemIndex = NULL, checkedRow) else if printNonEqual then print("["*i, j*"]", firstRow, Row(checkedMatrix, i)) end if; return false end if end do end do; return true end proc; addValues := proc (initEl) local el; el := sort(initEl, `>`); return MakeUnique([op(permute(el)), op(permute([-el[1], el[2], el[3]])), op(permute([el[1], -el[2], el[3]])), op(permute([el[1], el[2], -el[3]])), op(permute([-el[1], -el[2], el[3]])), op(permute([-el[1], el[2], -el[3]])), op(permute([el[1], -el[2], -el[3]])), op(permute([-el[1], -el[2], -el[3]]))]) end proc; arrayDiff := proc (array1, array2) local item, result; result := Array(); for item in array1 do if not has(array2, item) then Append(result, item) end if end do; return result end proc; checkHermitCondition := proc (self) local checkMatrix; checkMatrix := calculateEachValue(evalm(`&*`(self:-f0, self:-f1))); return checkMatrix end proc end module;


