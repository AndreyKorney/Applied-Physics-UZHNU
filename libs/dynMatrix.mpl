
read "libs/utilities.mpl"; with(LinearAlgebra); with(ArrayTools); with(plots); with(combinat); with(ListTools); with(Statistics); with(linalg); with(UtilitiesPackage);
DynMatrix := module()  option object;     export groups;  export eigs;   export modFunctions;  export degenerateValues;   export waveVectors;   export path ;  export B;  export A;  export simpleB;     export powerConstants;  export positions;   export modVectors;   export masses;   export maxBarrier;     export ModuleApply::static := proc()          Object( DynMatrix, _passed );  end proc;     export ModuleCopy::static := proc( self::DynMatrix, proto::DynMatrix, pos, pos2, mods, masses, consts, defK, path, steps, maxBarrier, $ )  local coords,  l, k, currentModifier, graph, kx,ky,kz,  A, points, temp,i, countOfValues;        self:-maxBarrier:=maxBarrier;       self:-positions:=pos;      self:-masses:=masses;      self:-modVectors:=mods;           self:-waveVectors:=defK;       self:-powerConstants:=consts;      self:-modFunctions:=getMasModFunctions(self, pos2, mods,masses);      self:-eigs:=Array([]);      self:-path := path;      self:-groups:=generateGroups(pos);     self:-B:=getDefMasMatrix(self);     self:-degenerateValues := Array([]);       countOfValues:=numelems(findNonNullValues(self:-masses)) * 3;   points:=steps-1;      for l from 0 to points  do    if points = 0 then  currentModifier:=0;  else     currentModifier:=(l)/(points ) * path;  end if;    kx:=getInRange(currentModifier, self:-waveVectors[1]): ky:=getInRange(currentModifier, self:-waveVectors[2]):  kz:=getInRange(currentModifier, self:-waveVectors[3]):   print(kx, ky, kz);    self:-A:=getGeneralDynamixMatrix(self,  kx,ky,kz):   temp:=roundToCertainDigits(Re(Eigenvalues(self:-A, evalf(LinearAlgebra:-Copy(self:-B))))):      temp:=selectValues(temp, countOfValues):        for i from 1 to numelems(temp) do  temp[i]:=(Re(sqrt(temp[i])))/( (2*Pi) * 3 * 10^(10)*33.356);  end do:    print(temp);    print("==============================================================");     Append(self:-eigs, temp):   Append(self:-degenerateValues, getDegenerateValues(temp)):   end do:      end proc:       export getDynamicMatrix::static := proc(positions, os1, os2, alfa)  local n,  d;    n:= findN(positions[1]);  d:=add(dynamicStep(pos, os1,os2,n), pos in positions);   return alfa * d;   end proc:      export getDynamicMatrixes::static:=proc(pos, alfa)    return Matrix(3, 3, (l,j)->getDynamicMatrix(pos, l, j, alfa)):  end proc:      export getSumOfDynMatrixes::static := proc(groups, alfa)  local sumOfMatrixes;     sumOfMatrixes:=add(getDynamicMatrixes(groups[l], alfa[l]), l=1..numelems(groups));   return unapply(sumOfMatrixes, kx,ky,kz);  end proc:      export getGeneralDynamixMatrix::static := proc(self, kx, ky, kz)  local sumOfMatrixesFunc, l, m, n, lenVectors, lenComponents, temp, A, colPosition, rowPosition, setOfPositions, powerConstants, setOfVectors;    setOfPositions:=self:-groups;  powerConstants:=self:-powerConstants;    setOfVectors:=self:-modVectors;    lenVectors := numelems(setOfVectors);  lenComponents:=3;    sumOfMatrixesFunc:=getSumOfDynMatrixes(setOfPositions, powerConstants):  rowPosition:=1: colPosition:=1:   A:= Matrix(lenVectors * lenComponents, lenVectors * lenComponents);   for l from 1 to lenVectors do    temp:= sumOfMatrixesFunc(kx+setOfVectors[l][1], ky+setOfVectors[l][2], kz +setOfVectors[l][3]);     for m from 1 to lenComponents do  for n from 1 to lenComponents do  A[rowPosition, colPosition + n - 1] := evalf(temp[m,n]);  end do:  rowPosition := rowPosition + 1;  end do;   colPosition:=colPosition+lenComponents;   end do:  return A;  end proc:     export getDefMasMatrix::static := proc(obj)  local l, j,  k, lenqq, B, index, basisVectors,  listOfVectors, masModFunctions,current, a, possibleVectors;  listOfVectors:=obj:-modVectors;   masModFunctions:=obj:-modFunctions;    lenqq := numelems(listOfVectors);  basisVectors :=getBasisVectors(obj:-maxBarrier):  B:= Matrix(lenqq, lenqq);    for l from 1 to lenqq do   possibleVectors:=Array(1..lenqq);    for j from 1 to lenqq do  possibleVectors[j]:=listOfVectors[j];  end do;    for j from 1 to lenqq do   current :=listOfVectors[l] - listOfVectors[j];   index:=0;     for k  from 1 to numelems(basisVectors) do   index:= findElemInArray(possibleVectors,current + basisVectors[k]);   if evalb(index> 0) then   B[l,j]:= masModFunctions[index];  possibleVectors[index]:=99999;  break;end if;  end do:     if evalb(index = 0) then B[l, j] := 0 end if:    end do:   end do:  obj:-simpleB:=B:   return KroneckerProduct(B, Matrix(3, shape=identity)):  end proc:           export getMasModFunctions::static := proc (self, positions, modVectors, masses)  local len, l, j, f1:   len:= numelems(modVectors):  f1:=Matrix(len,len, (l,j)->exp((-1)*I*( add(x, x in zip(`*`, positions[l], modVectors[j]))))/len):    return simplify(evalm(f1&*masses)):  end proc:        local sortingGroups::static:=proc(group1,group2)   local n1, n2, result:  n1:= findN(group1[1]):  n2:= findN(group2[1]):  result:= evalb(n1^(2) < n2^(2)):  return  result:    end proc:     local sortingPositions::static:=proc(elem1, elem2)  local n1, n2:  n1:= findN(elem1):  n2:= findN(elem2):  return evalb(evalf(n1^(2)) < evalf(n2^(2))):    end proc:      export getBasisVectors::static:=proc(initialElement)  local basisVariants, buffer, currentSum,l, basisVector, variant, sortproc:  buffer:=table():  buffer[seq([0,0,0])] :=1:     basisVariants:= addValues(initialElement):    for l from 1 to 5 do  for basisVector in indices(buffer) do  for variant in basisVariants do  currentSum:=basisVector+variant:  buffer[seq(currentSum)]:=1:  end do:  end do:   end do:     return sort([indices(buffer)], sortingPositions):   end proc:      export generateGroups::static:=proc(positions)  local uniq, groups, sortproc:  uniq:= MakeUnique([seq(convert(sort(abs(convert(positions[l], Array))), list),l=1..numelems(positions))]):  uniq:=remove(t-> t=[0,0,0], uniq):       groups:= [seq(addValues(uniq[l]), l=1..numelems(uniq))]:    sortproc := proc(a, b)  return sortingGroups(a,b):  end  proc:    return sort(groups, sortproc): end proc:    export selectValues::static:=proc(arr, number)  local cleaned, result, i,avg,minDiff,minValue,j:   cleaned:= Array([]):  for i from 1 to numelems(arr)do  if not arr[i]=Inf  and not arr[i] = -Inf  then  Append(cleaned, arr[i]):  end if:  end do:  result:=Array([]):  avg:=0:  for i from 1 to number do  minDiff:=infinity:  minValue:=infinity:  for j from 1 to numelems(cleaned) do  if abs(avg - cleaned[j]) < minDiff then  minValue:=j:  minDiff:=abs(avg - cleaned[j]):  end if; end do:    if minValue < infinity then  Append(result, cleaned[minValue]): cleaned:= removeElem(cleaned, minValue):  end if:      end do:  return sort(result):  end proc;    export addValues::static:=proc(initEl)  local el:=initEl:   return MakeUnique([op(permute(el)), op(permute([-el[1], el[2], el[3]])),op(permute([el[1], -el[2], el[3]])),op(permute([el[1], el[2], -el[3]])),op(permute([-el[1], -el[2], el[3]])),op(permute([-el[1], el[2], -el[3]])),op(permute([el[1], -el[2], -el[3]])),op(permute([-el[1], -el[2], -el[3]]))]):     end proc:       export  findN::static:=(pos)->sqrt((pos[1] )^(2)+(pos[2])^(2)+(pos[3])^(2)):   export dynamicStep::static:=(pos, os1, os2, n)  ->((pos[os1]*pos[os2] )/n^(2))*(1-exp(I*(kx*pos[1]+ky*pos[2]+kz*pos[3]))):     end module:
